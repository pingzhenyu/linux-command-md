## grep ##

强大的文本搜索工具

### 补充说明 ###

**grep** （global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。

grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。

###  语法

	grep [OPTIONS] PATTERN [FILE...]

###  选项
	-a --text  # 不要忽略二进制数据。
	-A <显示行数>   --after-context=<显示行数>   # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。
	-b --byte-offset                           # 在显示符合范本样式的那一行之外，并显示该行之前的内容。
	-B<显示行数>   --before-context=<显示行数>   # 除了显示符合样式的那一行之外，并显示该行之前的内容。
	-c --count    # 计算符合范本样式的列数。
	-C<显示行数> --context=<显示行数>或-<显示行数> # 除了显示符合范本样式的那一列之外，并显示该列之
                                                前后的内容。
	-d<进行动作> --directories=<动作>  # 当指定要查找的是目录而非文件时，必须使用这项参数，
                                        否则grep命令将回报信息并停止动作。
	-e<范本样式> --regexp=<范本样式>   # 指定字符串作为查找文件内容的范本样式。
	-E --extended-regexp             # 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则
                                       表达式。
	-f<范本文件> --file=<规则文件>     # 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本
                                     条件的文件内容，格式为每一列的范本样式。
	-F --fixed-regexp   # 将范本样式视为固定字符串的列表。
	-G --basic-regexp   # 将范本样式视为普通的表示法来使用。
	-h --no-filename    # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。
	-H --with-filename  # 在显示符合范本样式的那一列之前，标示该列的文件名称。
	-i --ignore-case    # 忽略字符大小写的差别。
	-l --file-with-matches   # 列出文件内容符合指定的范本样式的文件名称。
	-L --files-without-match # 列出文件内容不符合指定的范本样式的文件名称。
	-n --line-number         # 在显示符合范本样式的那一列之前，标示出该列的编号。
	-q --quiet或--silent     # 不显示任何信息。
	-R/-r  --recursive       # 此参数的效果和指定“-d recurse”参数相同。
	-s --no-messages  # 不显示错误信息。
	-v --revert-match # 反转查找。
	-V --version      # 显示版本信息。   
	-w --word-regexp  # 只显示全字符合的列。
	-x --line-regexp  # 只显示全列符合的列。
	-y # 此参数效果跟“-i”相同。
	-o # 只输出文件中匹配到的部分。
	-m <num> --max-count=<num> # 找到num行结果后停止查找，用来限制匹配行数

### grep正则表达式元字符集


####	字符匹配：
	. ：匹配任意单个字符；
	[]：匹配指定范围内的任意单个字符；
	[^]：匹配指定范围外的任意单个字符；
	
	标准的字符类名称如下：
	[:alnum:] - 字母数字字符
	[:alpha:] - 字母字符
	[:digit:] - 数字: '0 1 2 3 4 5 6 7 8 9'
	[:lower:] - 小写字母: 'a b c d e f g h i j k l m n o p q r s t u v w x y z'
	[:upper:] - 大写字母: 'A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'
	[:blank:] - 空字符: 空格键符 和 制表符
	[:space:] - 空格字符: 制表符、换行符、垂直制表符、换页符、回车符和空格键符

#### 位置锚定：
	^：行首锚定；用于模式的最左侧；
	$：行尾锚定；用于模式的最右侧；
	^PATTERN$：用于PATTERN来匹配整行；
	^$：空白行；
	^[[:space:]]*$：空行或包含空白字符的行；
	\< 或 \b：词首锚定，用于单词模式的左侧；
	\> 或 \b：词尾锚定，用于单词模式的右侧；
	\<PATTERN\>：匹配完整单词；
	单词：非特殊字符组成的连续字符（字符串）都称为单词；

#### 匹配次数：
用在要指定其出现的次数的字符的后面，用于限制其前面字符出现的次数；默认工作于贪婪模式；

	*：匹配其前面的字符任意次；0,1,多次；
	.*：匹配任意长度的任意字符
	\?：匹配其前面的字符0次或1次；即其前面的字符是可有可无的；
	\+：匹配其前面的字符1次或多次；即其面的字符要出现至少1次；
	\{m\}：匹配其前面的字符m次；
	\{m,n\}：匹配其前面的字符至少m次，至多n次；
	\{0,n\}：至多n次
	\{m,\}：至少m次



####  分组及引用
	\(\)：将一个或多个字符捆绑在一起，当作一个整体进行处理；
		    \(xy\)*ab
	Note：分组括号中的模式匹配 到的内容会被正则表达式引擎自动记录于内部的变量中，这些变量为：
	\1：模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式所匹配到的字符；
	\2：模式从左侧起，第二个左括号以及与之匹配的右括号之间的模式所匹配到的字符；

正则表达式：Regular Expression 
    *：任意长度的任意个字符
    ?:任意单个字符
    []:匹配指定范围内的任意单个字符
    [^]:匹配指定范围外的任意单个字符
  
  位置锚定
    ^:行首锚定，此字符后的任意字符出现在行首
     grep --color '^r..t' /etc/passwd
    $：行尾锚定，此字符前的内容必须出现在行尾
    grep --color 'w$' /etc/inittab 
    ^$：空白行
    grep  '^$' /etc/inittab |wc -l
   单词锚定
    \<：其后面的字符必须作为单词的首部出现，也可\b
     grep --color '\<root' test3.txt 
    \>:其前的字符必须作为单词的尾部出现,也可\b 
    grep --color 'root\>' test3.txt


###  实例
	准备测试文件
	# man ls > ls.txt

### 1. 搜寻指定字符串“author”
	# grep author ls.txt
	有无引号，或者单双引号 效果是一样的，但是加上引号可读性好一点。另外如果要查询带引号的内容，需要用\进行转义
	# grep -n author ls.txt 显示行号；显示匹配字符“author”的行及行号
	
### 2. 	利用中括号 [] 来搜寻集合字节
	如果我想要搜寻 to 或 do 这两个单字时，可以发现他们有共同的 '?o'
	# grep -n [td]o ls.txt
	[]里面不论有几个字节，都仅代表某一个字符！ 而如果想要搜寻到有‘oo’字符
	# grep -n oo ls.txt
	
### 3. 行首锚定，查询“ls”开始的行
	先删除ls.txt文件前面几行的空格
	# grep -n ^ls ls.txt
	^ls: 匹配所有以ls开头的行
	
### 4. 行尾锚定，查询“ls”开始的行
	# grep -n contents$ ls.txt
	contents$: 匹配所有以contents结尾的行

### 5. 词首锚定，找出以dir开头的单词的行
 	# grep -n \dir ls
	\dir： 匹配包含以dir开头的单词的行
	
### 6. 任意一个字节 . 与重复字节 *，需要找出 gr？？p 的字串，亦即共有五个字节， 起头是 gr 而结束是 p 
	# grep -n 'gr..p' ls.txt
	. (小数点)：代表『一定有一个任意字节』的意思；
	* (星号)：代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态

### 7. 匹配其前面的字符m次,找出两个到五个o的连续字串
	修改ls.txt添加几个o
	# grep -n 'o\{2,5\}' ls.txt
	因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用字符\来让他失去特殊意义才行。


### 8. 查询ls返回结果中的目录
	# ls -l |grep "^d" 

### 9. 查找指定进程
	# ps -ef|grep sshd
	除最后一条记录外，其他的都是查找出的进程；最后一条记录结果是grep进程本身，并非真正要找的进程。

### 10. 查找指定进程个数
	# ps -ef|grep sshd -c
	# ps -ef|grep -c sshd


###  grep 查找源码

###  11. 递归查找并显示行号
	#  grep -rn memcpy

	在当前目录查找可以使用：
	不指定目录：”grep -rn memcpy”
	用”.“指定当前目录：”grep -rn memcpy .”
	其实这两者查找结果一样，但在输出格式上是有区别的，具体留给你去比较好了。
 	-r: 逐层遍历目录查找
	#  grep -rni memcpy

	选项”-i“或略大小写，这样除了匹配“memcpy”外，还可以匹配一些宏定义如”MEMCPY“和”Memcpy“等

###  12. 查找精确匹配结果
	如果只想精确匹配整个单词，则使用-w选项：
	# grep -rnw cp
